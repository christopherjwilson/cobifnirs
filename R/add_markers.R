#' @title Add markers to NIRS data
#' @description This function will add markers to the NIRS data. The data must be the format generated using \code{\link{import_nirs}} and markers must be in the COBI .mrk file with the exact same name and location as the original .nir file. The returned data will have the markers added as a new column. If there are duplicate markers (i.e. more than one marker sent within a 500ms window), the function will either allow duplicates or remove them, depending on the parameters set.
#' @param nirsData (DATAFRAME) A dataframe containing NIRS data in a long format that has been imported using the \code{\link{import_nirs}} function.
#' @param allowDuplicates (LOGICAL: optional) If TRUE, the function will allow multiple markers to be attached to the same data point in the data. This will cause extra rows in the output (see details). Default is FALSE.
#' @param removeDuplicates (LOGICAL: optional) If TRUE, the function will remove duplicate markers that are attached to the exact same sample point in the data, retaining only the first marker value for that particular sample point. Default is FALSE.
#' @return A dataframe with the markers added as a new column.
#' @details This function will add markers to the NIRS data. The data must be the format generated using \code{\link{import_nirs}} and markers must be in the COBI .mrk file with the exact same name and location as the original .nir file. The returned data will have the markers added as a new column.
#'
#' **How are markers added to the NIRS data?**
#'
#' In real time, the markers are often sent in-between the data acquisition points. However, the COBI marker (.mrk) file specifies which data point the marker should be attached to using a row value, which is the equivalent of the dataRow value in the NIRS data generated by \code{\link{import_nirs}}. This function will add the markers to the NIRS data by linking the value specified in the .mrk file to the dataRow value in the nirsData.
#'
#' **Dealing with duplicate markers:**
#'
#' I have found that when sending markers via a serial port connection, there is the possibility of sending duplicate markers. This happens if they are sent in quick succession, faster than the sampling rate of the fNIRS data acquisition. The result is more than one marker attached to the same data point in the original .mrk file -  (You can see this by opening the .mrk file in a text editor and looking at the 3rd column for duplicate values).
#'
#' Often, duplicates are not useful. However, it is also possible that the markers are sent at the same time intentionally, for example, marking the end of a trial and the start of the next trial. In this case, you may want to keep the duplicate markers.
#'
#' The allowDuplicates and removeDuplicates parameters allow you to choose how to handle duplicate markers.
#'
#'
#' @import dplyr
#' @import stringr
#' @import readr
#' @export
#' @seealso \code{\link{import_nirs}}
#' @examples
#'
#' \dontrun{
#'
#'  # import the NIRS data
#'
#'  nirsData <- import_nirs("path/to/nirs/file.nir")
#'
#' # The location of the marker file will be read
#' # from the fileName column of the nirsData dataframe.
#'
#' nirsData <- add_markers(nirsData)
#'
#' # Now let's assume there are duplicate values in the marker file.
#' # This could be problematic if it is unintentional.
#' # Equally, it could be completely fine for you if you are aware of this or did it intentionally.
#'
#' # If you run the function normally, it will return a message
#' # to let you know that there are duplicates.
#'
#' # We have 2 options: allow the duplicates or remove them.
#' # If we allow them, the output will have extra rows.
#' # These will be exact duplicates of the rows that have the same dataRow value (i.e. the same timepoint) but with the additional markers.
#' # You might want this, and it might cause no issues with your analysis.
#'
#' # To allow duplicates, set allowDuplicates = TRUE.
#' nirsData <- add_markers(nirsData, allowDuplicates = TRUE)
#'
#' # If we remove the duplicates, we will retain only the first marker value for that particular datapoint.
#' # This is will mean that only one of the markers will be linked to this exact datapoint.
#' # This might be useful if you are only interested in the first marker that was sent, or if you sent additional markers accidentally.
#' # The output will have the same number of rows as the input.
#'
#' #To remove duplicates, set removeDuplicates = TRUE.
#'
#' nirsData <- add_markers(nirsData, removeDuplicates = TRUE)
#'
#' }
#'
#'



add_markers <- function(nirsData, allowDuplicates = FALSE, removeDuplicates = FALSE){


    nirFileName <- nirsData$fileName[1]

  fullMrkPath <- paste(str_sub(nirFileName, 1, nchar(nirFileName)-4),".mrk", sep = "")  # name the marker file. If it exists, it should have exact same name as nir file

  # check the marker file exists. If not, stop the function

  if (!file.exists(fullMrkPath)){
   print( paste0("Marker file does not exist. Please make sure the marker file has the same name and location (full path) as the NIRS file with a .mrk extension. In this case, it should be: ", fullMrkPath, ". Returning data without any changes.")





          )
  } else {

  print(paste0("Marker file path: " , fullMrkPath))


  # read the marker file
  mrk1 <- read_lines(fullMrkPath)

  # convert to tibble
  mrk1 <- mrk1 %>% as_tibble()


  mrk1 <- dplyr::mutate(mrk1, id = row_number()) # overall row number is added to the file data. This helps to identify when the data actually begins in the file

  # getting the actual marker data
  mStartRow <-  mrk1 %>% dplyr::filter(str_detect(.$value, 'Freq Code:')) %>% dplyr::select(id)
  markerValues <- mrk1 %>% dplyr::filter(id > mStartRow$id & id <= max(id))

  # organising the marker data and adding the dataRow column to match with the same column in the nirs_data

  markerValues <- tidyr::separate(markerValues, col = value, sep = "\t", into = c("t","marker", "dataRow"), extra = "merge")

  # the dataRow column is converted to integer
  markerValues$dataRow <- as.integer(markerValues$dataRow)



  # select only the dataRow and marker columns
  mrk2 <- markerValues %>% dplyr::select(dataRow, marker)

  ## check for duplicate dataRow values

  if (any(duplicated(mrk2$dataRow))){

    if (!removeDuplicates && !allowDuplicates){
      print("Duplicate dataRow values found in the marker file. This means more than one marker was recorded within 500ms. This makes it impossible to link just one of the markers with the nir value at that time, so you might want to check the marker file and remove duplicates. Returning data without any changes for now. To allow duplicates, add the parameter allowDuplicates = TRUE. This will mean there will be extra rows in your nirsData output, which may not be what you want. To remove duplicates, add the parameter removeDuplicates = TRUE.")}

    if (removeDuplicates && allowDuplicates){
      stop("Both removeDuplicates and allowDuplicates are set to TRUE. This is not possible. Please set only one of these parameters to TRUE.")}

    if (removeDuplicates){
      print("Duplicate dataRow values found in the marker file. This means more than one marker was recorded within 1 sample period (e.g, 500ms @ 2Hz). This makes it impossible to link just one of the markers with the nir value at that time. Removing duplicates and retaining only the first marker value for that particular datapoint.")

      # if their are duplicates, remove them and retain only the first marker value for that particular datapoint
      mrk2 <- mrk2 %>% distinct(dataRow, .keep_all = TRUE)

      # merge the marker data with the nirs data

      nirsData <- dplyr::left_join(nirsData, mrk2, by = "dataRow")
    }


    if (allowDuplicates){
      print("Duplicate dataRow values found in the marker file. This means more than one marker was recorded within 1 sample period (e.g, 500ms @ 2Hz). This makes it impossible to link just one of the markers with the nir value at that time. Allowing duplicates. This will mean there will be extra rows in your nirsData output, which may not be what you want.")

      # merge the marker data with the nirs data

      nirsData <- dplyr::left_join(nirsData, mrk2, by = "dataRow")
    }

  } else {
    # merge the marker data with the nirs data
    nirsData <- dplyr::left_join(nirsData, mrk2, by = "dataRow")

}



  }

  nirsData
}
